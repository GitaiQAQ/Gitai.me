---
layout:     post
title:      "用 SVG + Canvas + WASM 实现高性能下发图"
date:       2019-04-24
author:     "Gitai"
categories:
	- Rust
tags:
	- 状态机
	- Rust
---

V2 上面看到个推分享的[数据可视化之下发图实践](https://www.v2ex.com/t/556279)。

![下发图 Demo](https://diycode.b0.upaiyun.com/photo/2019/c8bf9ab0e153ea3d4e8e96af221ea252.gif)

觉得挺有意思的，但是没用 Demo，所以在此尝试实现一下，并觉得他们的技术选型有问题。

![两款技术栈的具体性能对比](https://diycode.b0.upaiyun.com/photo/2019/c5bb8be7371282d71c7f808433cafb50.png)

首先，SVG 非原生的动画，实现上频繁触发 DOM 操作，要不然 SVG 本身性能应该不会比 Canvas 差。

所以我准备复合上述 2 种方案，并且引入 WASM 优化计算逻辑，直接调用 Canvas。

<!--more-->

## 使用 SVG + CSS 实现静态地图图层

在上述文章种，使用了阿里云的 datav 中获取地图的 geojson 数据，然后通过 canvas 原生 Api，添加背景色、边框等，绘制地图。
我觉得可以把这块抽离出来，直接在 datav 上下载[对应的 SVG](https://datav.aliyun.com/tools/atlas/)，然后附加 CSS 作为底层，再通过全覆盖一个 Canvas 绘制动画，来解决。

于是有了以下的实现方案：

1. 数据准备和清理，获取 SVG 和 下发图的对应坐标
2. 附加对应的属性，生成合适的背景图
3. 实现动态下发过程动画

### 数据准备和清理

下载 SVG，清理属性（移除除了 `d` 以外的全部属性）方便之后通过 CSS 创建合适的样式。

调整视口，选个刚好能显示，又不会多余的尺寸（`viewBox="300 0 900 800"`）

用取色器从上面的 Demo 获取到背景色`#0d1531`，地图填充颜色`#051132`，省界颜色`#032649`，地图厚度颜色`#2083bc`，地图阴影颜色`#000`。

### 生成合适的背景图

设置颜色到对应区块上，并设置合适的边框样式。
	
datav 获取的地图，分为 2 类节点，首个节点是整个版图，之后的是各省的区块；从上面的 Demo 能看出来，他有省市的轮廓和国界的轮廓，并且采用不同的颜色，之后是下面的投影。

<p class="codepen" data-height="265" data-theme-id="0" data-default-tab="html,result" data-user="gitaiqaq" data-slug-hash="dLarbR" data-preview="true" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="dLarbR">
  <span>See the Pen <a href="https://codepen.io/gitaiqaq/pen/dLarbR/">
  dLarbR</a> by Gitai (<a href="https://codepen.io/gitaiqaq">@gitaiqaq</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

接下来给 `svg` 增加投影：

```css
.shadow {
    filter: drop-shadow(-5px 5px 9px #000000);
}
```

并给第一个`g` 容器增加一个位移 `transform`，并设置一个颜色，用来伪造侧视图产生的高度。

```css
.pseudo-3d {
    fill: #ff00b6;
    transform: translate(-3px,3px) scale(1.002);
}
```

然后复制这个 `g` 容器，修改他的颜色和描边。

![1556375943711](C:\Users\gitai\AppData\Roaming\Typora\typora-user-images\1556375943711.png)

因为需要给省界和国界划定不同的描边宽度，而从上图不难发现，国界和省界在 SVG 上面是重叠的，所以无法直接完成对不同颜色的添加。

但是从填充颜色和描边的范围我们也能发现，省界的映射刚好是下层元素的 `fill` 范围，而国界和下层元素的 `stroke` 完全重合。

于是我们能获得如下启发，将上层的元素的描边颜色设为 `transparent`，这样就可以直接显示下层对应位置的颜色了。

```css
.national-boundaries {
    fill: #fff;
    stroke: #000;
    stroke-width: 2px; 
}
```

<p class="codepen" data-height="265" data-theme-id="0" data-default-tab="html,result" data-user="gitaiqaq" data-slug-hash="jRdJVg" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="jRdJVg">
  <span>See the Pen <a href="https://codepen.io/gitaiqaq/pen/jRdJVg/">
  jRdJVg</a> by Gitai (<a href="https://codepen.io/gitaiqaq">@gitaiqaq</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

已经初见雏形了，接下来把刚开始就晾在一边的省界放上来。

> 注意：河北，天津，北京被注释是为了更好地观察上面通过透明创造的色差。

<p class="codepen" data-height="265" data-theme-id="0" data-default-tab="html,result" data-user="gitaiqaq" data-slug-hash="VNgRNG" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="VNgRNG">
  <span>See the Pen <a href="https://codepen.io/gitaiqaq/pen/VNgRNG/">
  VNgRNG</a> by Gitai (<a href="https://codepen.io/gitaiqaq">@gitaiqaq</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

到这里，静态的中国地图已经差不多完成了，但是还不够立体，虽然加了伪造的投影效果，但是实际上的地图并没有任何变化。这时候就需要对整个 SVG 加上空间变换。

```diff
body > * {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 430px;
+   transform: rotateX(45deg);
}
```

到这里第一个图层才算完成了，虽然很丑，但是改改配色还是可以用的。

![1556377054219](C:\Users\gitai\AppData\Roaming\Typora\typora-user-images\1556377054219.png)

这才是初版，但是代码写得见不得人。

或许有人会注意到最开始有这么一段代码

```css
body > * {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 430px;
}
```

当我们完成背景图层的创建，还需要一个 Canvas 覆盖上来，来绘制动画；于是将其包起来，用绝对定位放在一起。所以接下来就是添加 Canvas 元素，准备 WASM 环境了。

### 动态下发过程动画

先准备 WASM 环境，参见 [Rust wasm-bindgen](https://rustwasm.github.io/docs/wasm-bindgen/) 官方文档，这里就是私货了，Rust 写起来那么舒服是吧？快吃了这口安利。

> 未完成