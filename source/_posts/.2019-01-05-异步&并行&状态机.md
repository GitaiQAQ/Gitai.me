---
layout:     post
title:      "异步&并行&有限状态机"
date:       2019-01-05
author:     "Gitai"
categories:
	- JavaScript
tags:
	- CSP
	- 有限状态机
	- Promise
	- 并发编程
	- Golang
---

自从上次面试失败，又继续看了看书，突然顿悟一点点小东西。大概就是脱离语言的模型，思想或者小技巧。

首先从并发模型说起，之前就听说《七周七并发模型》[^1]这本书，但是一直没时间看看，因为觉得可能一段时间内都用不上这些东西。但是看完之后还是有所体会的。

<!-- more -->

书中从多线程环境下的竞态问题开始入手，加入悲观锁阻止多线程同时对数据的操作，但是因为指令的非顺序执行之类的问题导致结果也单线程下的预期不一致。

引入了多把锁，但是大大增加了并发时阻塞发生的概率。在 `ConcurrentHashMap` 中使用分治的思想通过二次哈希分块，来降低阻塞的概率。

之后另辟蹊径，用函数式的不可变状态来跳过竞态问题。个人觉得这点像极了值传递，但其实这应该理解为加了约束的引用传递。（其实思考这个问题就很蠢，面向过程和函数式就不是一个东西）

CSP 模型[^1], 有限状态机, 并发编程, Go块

## 参考

[^1]: https://book.douban.com/subject/26337939/	七周七并发模型

[^2]: http://www.cnblogs.com/penghuwan/p/7451409.html 异步编年史，从“纯回调”到Promise

[^3]: https://juejin.im/post/5bd2b8a6e51d452700138e01 从Promise的实现来看有限状态机

[^4]: http://chenhanhui.com/2016/05/26/Promise%E7%9A%84%E5%AE%9E%E7%8E%B0/ Promise的实现

[^5]: https://juejin.im/entry/5a0261566fb9a0451b03f7f6 ES6 Generator函数实现协同程序

[^6]: https://www.jianshu.com/p/8ec105854e05 Getting Concurrent With ES6 Generators

[^7]: http://maples7.com/2017/10/17/understand-callback/ 完全理解回调函数