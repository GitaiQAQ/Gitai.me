title: 漫谈整型
date: 2016-12-11 11:52:18
tags:
	- C
	- math
---

## Size of Int[^numbers-in-javascript]

> 
short、int 和 long 类型都表示整型值，存储空间的大小不同。一般，short 类型为半个机器字长（word）长，int 类型为一个机器字长，而 long 类型为一个或两个机器字长（在32位机器中 int 类型和 long 类型通常字长是相同的）。<div style="text-align: right;">—— C++ Primer</div>

64-Bit Integer Type Systems

|    Type    | ILP16 | ILP32 | ILP32LL | LP64 | ILP64 | LLP64 |
|    :--:    | :---: | :---: | :-----: | :--: | :---: | :---: |
|    char    |   8   |    8  |     8   |   8  |   8   |   8   |
|    short   |   16  |   16  |    16   |  16  |  16   |  16   |
|     int    |   16  |   32  |    32   |  32  |  64   |  32   |
|    long    |   32  |   32  |    32   |  64  |  64   |  32   |
|  long long |   00  |  N/A  |    64   |  64  |  64   |  64   |
|   pointer  |   16  |   32  |    32   |  64  |  64   |  64   |

: 中间的数字表明你是 64bit 还是 32bit 的机器.前面的 I 表示 int， L 表示 long， LL 表示 long long， P 就表示 pointer。位于数字前面的类型表示跟中间的 bit 数保持一致。 举个样例: ILP32LL 就是 ILP 是 32 位， LL 是 64 位。

编译器去适应平台。真正决定 int 占多少字节取决于你的设备平台。

```C
printf("short\t\t%d\n", sizeof(short));    
printf("int\t\t%d\n", sizeof(int));
printf("long\t\t%d\n", sizeof(long));
printf("float\t\t%d\n", sizeof(float));
printf("double\t\t%d\n", sizeof(double));  
printf("long double\t%d\n", sizeof(long double));    
printf("char\t\t%d\n", sizeof(char));  
```

```
type            bytes
short           512
int             512
long            1024
float           1024
double          1024
long double     1024
char            256
```

事实上不管哪种模型 short 和 char 不管哪种平台下都保持一致。

我们见得最多的就是 ILP32LL 模型。 这样的模型下 int 和 long 已经 pointer 占 4 个字节 long long 占8个字节。

伴随 64-bit 广泛运用， LP64 模型成为基准。

<!-- more -->

## 机器码、真值[^numbers-in-javascript]

机器码
: 整数在计算机中二进制形式。规则很简单，机器码的最高位（左第一位）表示数字的正负，0 表示正数，1 表示负数，其余位按照进制转换的规则表示具体数字。

真值
: 机器码按照上述转换规则还原的带有正负的实际整数。

举例，用 8-bits 表示一个整数，则十进制的整数 +6 可表示为：0 000 0110 ；十进制的数字 -5 可表示为 1 000 0101 。这里说的 +6 和 -5 便是真值，而表示它们的二进制数便是机器码。

再次注意，最高位只用于表示正负，比如 1 000 0101 的真值是 -5 而非 133，以及我们关于机器码和真值的讨论是基于整数范围的，浮点数在计算机中的存储方式与整数有很大差值，将另作讨论。

## 原码、反码、补码

机器码分为多种，主要包括 `原码`、`反码`、`补码`、`移码`等，今天我们主要总结一下前三个，而移码非常简单，且多用于比较，不做详细说明。另外需要补充一点，我们在此区分机器码的这么多种形式，主要是针对的有符号数，而无符号数，不需要使用最高位来表示正负，也就不需要这么多种编码方式。

### 原码

最高位表示正负，其它位表示真值的绝对值。其中，最高位为 0 表示正数或者 0 ，为 1 表示负数。

比如，同样以 8bits 长度的数串表示 +7 的原码为 0 000 0111，-7 的原码为 1 000 0111 。以后，我们会这样表示：

$$
[+7] = [0 000 0111]_原\\
[-7] = [1 000 0111]_原
$$

很明显，8-bits 的原码能记录的范围为：$[-127,+127]$。

原码的好处在于，易于理解，相对直观，方便人脑识别和计算。

对于原码，人脑使用，可以直接计算出其真值然后可以进行后续操作。但对于计算机，首先，因为最高位用于表示正负，所以不能直接参与运算，需要识别然后做特殊处理；其次，具体计算使用绝对值进行操作，所以两个操作数正负的异同会影响操作符，比如两个异号相加实际要做减法操作，甚至异号相减还需要判断绝对值大小然后决定结果正负。如此，我们计算机的运算器设计将会变得异常复杂。下面，我们将了解如何使用反码和补码将符号位参与运算，从而使加减法统一简单高效地处理，这也是反码和补码出现的原因。

### 反码

正数的反码等于其原码，而负数的反码则是对其原码进行 __符号位不变，其它位逐一取反__ 的结果。

比如，同样以 8-bits 长度的数串表示 +7，那么有如下：

$$
[+7] = [0 000 0111]_原 = [0 000 0111]_反\\
[-7] = [1 000 0111]_原 = [1 111 1000]_反
$$

同样，8-bits 的反码能记录的范围为：$[-127,+127]$ 。

在按位取反之后，我们可以有下面的操作：
$$
\begin{eqnarray*}
2 - 3 &=& 2 + (-3)\\ 
      &=& [0 000 0010]_原 + [1 000 0011]_原\\ 
      &=& [0 000 0010]_反 + [1 111 1100]_反\\
      &=& [1 111 1110]_反 = [1 000 0001]_原\\
      &=& -1
\end{eqnarray*}
$$

上面，我们将减法通过反码转化为了加法，如此，我们的运算将会简单很多，但是反码的方式同样存在一些问题：

$$
\begin{eqnarray*}
3 - 3 &=& 3 + (-3) \\
      &=& [0 000 0011]_原 + [1 000 0011]_原 \\
      &=& [0 000 0011]_反 + [1 111 1100]_反 \\
      &=& [1 111 1111]_反 \\
      &=& [1 000 0000]_原 \\
      &=& -0
\end{eqnarray*}
$$

出现了 -0 ，这个值是没有意义的。另外，按照反码加法法则，如果最高位有进位，需要在最低位上 +1 ，那么会出现：

$$
\begin{eqnarray*}
3 - 2 &=& 3 + (-2) \\
      &=& [0 000 0011]_原 + [1 000 0010]_原 \\
      &=& [0 000 0011]_反 + [1 111 1101]_反  (这里最高位有进位，需要在最低位 +1) \\
      &=& [0 000 0001]_反 \\
      &=& [0 000 0001]_原\\
      &=& 1
\end{eqnarray*}
$$

这种情况，又增加了反码运算的复杂性，影响效率，为解决上面的问题，出现了补码。

### 补码

正数的反码等于其原码，而负数的补码则是对其反码进行末位 +1 的结果。

比如，再同样以 8-bits 长度的数串表示 +7 ，那么有如下：

$$
[+7] = [0 000 0111]_原 = [0 000 0111]_反 = [0 000 0111]_补\\
[-7] = [1 000 0111]_原 = [1 111 1000]_反 = [1 111 1001]_补
$$

使用补码，继续做之前的操作：

$$
\begin{eqnarray*}
2 - 3 &=& 2 + (-3) \\
      &=& [0 000 0010]_原 + [1 000 0011]_原 \\
      &=& [0 000 0010]_反 + [1 111 1100]_反 \\
      &=& [0 000 0010]_补 + [1 111 1101]_补 \\
      &=& [1 111 1111]_补 \\
      &=& [1 111 1110]_反 \\
      &=& [1 000 0001]_原 \\
      &=& -1
\end{eqnarray*}
$$

那么，如果是 3-3 呢？

$$
\begin{eqnarray*}
3 - 3 &=& 3 + (-3) \\
      &=& [0 000 0011]_原 + [1 000 0011]_原 \\
      &=& [0 000 0011]_反 + [1 111 1100]_反 \\
      &=& [0 000 0011]_补 + [1 111 1101]_补 \\
      &=& [0 000 0000]_补 \\
      &=& [0 000 0000]_原 \\
      &=& 0
\end{eqnarray*}
$$

是否还需要做额外的加法操作？

$$
\begin{eqnarray*}
3 - 2 &=& 3 + (-2) \\
      &=& [0 000 0011]_原 + [1 000 0010]_原 \\
      &=& [0 000 0011]_反 + [1 111 1101]_反 \\
      &=& [0 000 0011]_补 + [1 111 1110]_补 \\
      &=& [0 000 0001]_补 \\
      &=& [0 000 0001]_原 \\
      &=& 1
\end{eqnarray*}
$$

这样，我们便可以完美的将减法统一到加法之上，而且不需要繁琐的正负判断，进位控制，甚至可以节约一个位置。那么，这个位置，也就是 10000000 如何处理呢？按照规定，10000000 用来表示 -128 ，正数的补码/反码/原码相同，而负数的补码只是占用了 -0 的 [1 000 0000] 原和 [1 111 1111] 反转换后得到的[1 000 0000]补表示 -128 ，但是这个只是帮助理解，不能反向回推得到 -128 的原码和补码。

所以，8bits 的补码能记录的范围为：[$-128$,$+127$]。

至此，我们已经了解了，计算机中主要使用的存储和计算整数的方式，鉴于现代计算机主要使用补码方式，自然能很容易理解各种数字类型的表示范围，比如 32bits 的 int 范围为：[$-2^{31}$,$2^{31}-1$]。

### 标准的基本原理

我们知道，对于计算机而言，数字没有小数和整数的差别，也就是计算机中没有小数点的存在。通过前文的讨论，我们已经找到了很完美的整数存储计算的方案，但是当涉及到小数，我们很容易发现，现有的方案无法解决我们的需求。然后，计算机科学家们便尝试了多种方案，主要便是定点数和浮点数两种。

所谓定点数，是指小数点位置固定在数串中间的某个特定位置，点两侧分别为数字的整数和小数部分。比如用 8-bits 字长的数串，小数点固定在正中间位置，那么 11001001 和 00110101 分别表示 1100.1001 和 11.0101 两个数字。这种方案简单直观易理解，但是存在严重的空间浪费，以及容易溢出的问题。

所谓浮点数，是指小数点的位置是不固定的，通过科学计数法(这个应该不需要解释吧)的方式控制小数点的位置，表示不同的数字。这个表示方案便是 IEEE 754 标准使用的方案。IEEE 754 标准是目前使用最广泛的浮点数运算标准。下面我们将主要讨论一下此方案。

现在，让我们想一下小时候学习的科学计数法，比如-123.456这个数字，转换成科学计数法应该是：$-1.23456 × 10^2$。这里面已经包含了IEEE 754 标准的主要元素。我们梳理一下：第一个，自然是正负号的问题，需要一个标志；然后，需要一个具体的数字，表示有效数字或者精度，如上例的 1.23456 ；再然后，需要一个控制小数点位置的数字，如上例的 $10^2$ ，回忆一下，我们学习科学计数法的时候，要求前面的数字的绝对值大于 1 而小于 10 ，也就是小于 $10^2$ 中的底数(Base)，进制固定之后，底数应该是固定的，所以这里起决定作用的是指数，也就是上例中的 2 。那么，有了这三个元素，我们便可以很轻松的表示出一个数字，并且灵活的调节小数点位置从而控制数字正负、精度和大小。

上面的要素，转换成标准语言描述，我们称表示正负的标志叫符号(Sign)，表示精度的数字为尾数(Mantissa)或者有效数字(Significand)，而控制小数点位置的指数就叫指数(Exponent)，指数和基数(Base)共同作用参与计算。下图取自wikipedia，我们直观地感受下这三个要素在一个数串中的相对关系（fraction区域即等同于前面说的有效数字区域）：

![此处输入图片的描述][1]

了解最基本的原理后，我们来大致看一下IEEE 754标准做了什么。

首先做的事情就是规定这三个要素在一个数串中占有的位数，试想一下，如果各个实现的位数不确定，那么我们是不是很难正确的还原出原始数字？IEEE 754标准规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80比特实做）。只有32位模式有强制要求，其他都是选择性的。而现在主流的语言，多提供了单精度和双精度的实现，我们在此主要比较一下这两者，如图是它们各个部分对应上图，所使用的位数如下：

![此处输入图片的描述][2]

补充一点的是，无论是科学计数法还是标准的规定，都要求有效数字（不考虑符号位）必须 `>=1` && `< Base`。所以，有效数字其实是一个定点数，小数点的位置固定在有效数字域的最高位和次高位之间。

那么，按照上述规定，在二进制中，最高位只能是 1 ，所以标准要求省略其最高位，于是精度提高一位。

比如，32-bits 的单精度有效数字区域只有 23 位，但是精度却是 24 位；64-bits 的双精度，拥有 52 位的有效数字域却是 54 位精度的。

然后，还有一个问题，如果按照先有的约定，是不是无法表示小于 1 的实数？因为，指数一定 `>=0` ，有效数字一定 `>1`。于是，IEEE 754 标准提出了一个很重要的指数偏移值。它是说明指数域(Exponent占用的区域)的编码值为指数的实际值加上某个固定的值，换言之便是，如果我们根据指数域计算出的指数是 N，那么参与计算实际浮点数的指数应该是 N- 指数偏移值。根据 IEEE 754 标准的规定，该固定值为 $2^{e-1} - 1$ ，其中的 e 为存储指数的比特的长度。

比如，从上图中我们看到，32-bits 的单精度是以 8-bits 表示一个指数域，那么偏移值应该是 $2^{8-1} - 1 = 128−1 = 127$ 。

所以，容易得出，单精度浮点数的指数部分实际取值是 $[-127,128]$ 。比如，某个 32-bits 单精度的指数为十进制的 1 ，那么指数域的编码应该是 10000001，某个 32-bits 单精度的指数域编码是 00000001，那么该指数的实际值应该是十进制的 -126。这样，我们就能通过偏移值将正指数转换为负指数，从而使浮点数能逼近 0。浮点数的指数计算跟前面讨论的机器码恰好相反，正数的最高位都是 1，而负数的最高位都是 0。

以上的描述，便是 IEEE 754 标准最需要我们了解的原理部分。

但是，作为一个广泛使用的工业标准，规定这些还是远远不够的。

### 补充

wikipedia对IEEE 754标准有如下描述：

> 
这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number）），一些特殊数值（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。


下面，补充几个，我认为与本文后续讨论相关的或者可以帮助大家理解极端现象的定义：

规约形式的浮点数
: 如果浮点数中指数部分的编码值在 `0 < exponent < 2^(e-1)` 之间，且尾数部分最高有效位（即整数字）是 1，那么这个浮点数将被称为规约形式的浮点数。也就是，严格按照我们上文描述编码的数字。

非规约形式的浮点数
: 如果浮点数的指数部分的编码值是0，尾数为非零，那么这个浮点数将被称为非规约形式的浮点数。
IEEE 754标准规定: 非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值大 1.例如，最小的规约形式的单精度浮点数的指数部分编码值为 1，指数的实际值为 -126 ；而非规约的单精度浮点数的指数域编码值为 0，对应的指数实际值也是 -126 而不是 -127 。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近 0。规约浮点数的尾数大于等于 1 且小于 2 ，而非规约浮点数的尾数小于 1 且大于 0。

上面的两个概念，几乎是直接从wikipedia上扒下来的，非规约形式的浮点数出现的意义是避免突然式下溢出（abrupt underflow），而采用渐进式下溢出。

这已经是上世纪70年代的事情了，差不多是我的年龄的两倍了。

这个是一些非常极端的情况，在此我尝试最简单地描述一下非规约形式的浮点数出现的意义，知道有这么回事便可：下面，以单精度为例，如果没有非规约形式的浮点数，那么绝对值最小的两个相邻的浮点数之间的差值将是绝对值最小的浮点数的 $\frac{1}{2^{23}}$，大家想一下，绝对值次小的浮点数减去绝对值最小的浮点数的值是多少？

$$
\begin{eqnarray*}
1.00...01 × 2^(-126) - 1.00...00 × 2^(-126) &=& 0.00..01 × 2^(-126) \\
    &=& 1 × 2^(-126-23) \\
    &=& 2^(-149)
\end{eqnarray*}
$$

很明显，绝对值最小的规约数无法表达其和次小的规约数的差值，所以很容易导致有若干数字之间的差值下溢，可能会触发意料之外的后果。而如果采用非规约形式的浮点数，指数全0，偏移值比规约数偏移值大 1（-126比-127大1），尾数小于1，那么非规约数能表达的最小值便是：

$$
\begin{eqnarray*}
0.00..01 × 2^(-126) &=& 1 × 2^(-126-23) \\
                    &=& 2^(-149)
\end{eqnarray*}
$$

所以，非规约形式的浮点数解决了前述的突然式下溢出（abrupt underflow）而被标准采纳。

IEEE 754 标准还规定了三个特殊值：

指数全 0 且尾数小数部分全 0 ，则这个数字为 ±0。（符号位决定正负）
指数为 $2^e - 1$ 且尾数的小数部分全 0，这个数字是 ±∞ 。（符号位决定正负）
指数为 $2^e - 1$ 且尾数的小数部分非 0，这个数字是 NaN。
结合前面的规约数，非规约数以及三个特殊值，可以得到如下总结：

|    形式    |    指数   | 小数部分 |
|     --:    |    :--:   |  :--:    |
|         零 |         0 |    0     |
| 非规约形式 |         0 |   !0     |
|   规约形式 | 1~$2^e-2$ |    *     |
|       无穷 |   $2^e-1$ |    0     |
|        NaN |   $2^e-1$ |   !0     |

现在，让我们回忆一下，各种语言中普遍描述的双精度浮点数的范围：$[-1.7 × 10^{-308},1.7 × 10^{308}]$ 。打个岔，想象一个有 300 多位的十进制数字的适用情形，私以为远超过普通人想象力的边界。这个范围为什么是这个范围呢？我觉得，通过上面的讨论，大家应该能清晰，$\frac{1.7}{308}$ 这些数字出现的必然原因。

首先，我们应该很容易根据偏移量得出双精度浮点数的计算公式：

$$
-1^{sign}\times2^{exponent-0\times3FF}\times1.mantissa
$$

然后，以正数为例，按照上述特殊值中 ±∞ 和 NaN 的约定，指数的最大值应该满足指数取规约数的指数范围的最大值，然后小数部分取小数部分的最大值，可以得出这个二进制的数字应该是：

$$ 0 11111111110 \underbrace{11..11}_{52} $$

转换为16进制表示：

$$ 0\times7FEF FFFF FFFF FFFF $$

那么，根据前述规约数的原理，反编码便得到十进制的：1.7976931348623157 x 10^308。类似的道理，Sign位取反，便是范围的下限。

到此为止吧，我对IEEE 754标准也是最近几天稍加学习，再说多了就误导大家了。通过这几天的学习，我感觉，我们在理解的IEEE 754标准及浮点数的时候，要特别注意将精度和范围两个概念分别开来。范围只是一个模糊的界限，精度才是能准确表达的数字。




  [1]: http://sxxz.u.qiniudn.com/jiqima-javascript-1.png
  [2]: http://sxxz.u.qiniudn.com/jiqima-javascript-3.jpg
  [^numbers-in-javascript]: [Numbers in JavaScript](http://jser.it/blog/2014/07/07/numbers-in-javascript/)
  [^llli]: [long long,long,int](http://blog.csdn.net/gao1440156051/article/details/44114917)
